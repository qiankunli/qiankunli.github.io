---

layout: post
title: calico学习
category: 技术
tags: Network
keywords: Docker, calico

---

## 简介

* TOC
{:toc}

Calico是一个纯3层的数据中心网络方案（也就是局域网网络方案），能够提供可控的VM、容器、裸机之间的IP通信。

[洪强宁：宜信的PaaS平台基于Calico的容器网络实践](http://www.infoq.com/cn/articles/ECUG2015-PaaS-Calico)

[容器网络插件 Calico 与 Contiv Netplugin深入比较](http://dockone.io/article/1935)

## calico 文档与安装

GitHub [projectcalico/calico](https://github.com/projectcalico/calico)

[官网](https://docs.projectcalico.org)

![官网](/public/upload/docker/calico.png)

1. 官网有对应各个平台的安装文档
2. calico 版本不同，安装细节也有所不同。
3. calico 从v3.0后 不再支持 mesos
4. calico 一开始是python开发，逐步转为python
5. calico 基础服务的启动方式演化
    1. calico 由felix（calico agent）、bgp client、bgp route reflector等组成，这些组件是下载二进制分别安装的
    2. 新版Calico服务是作为容器来运行的

[calico下载](https://github.com/projectcalico/calico/releases) 文件夹解压后的文件列表

    release-v3.10.0
    ├── README
    ├── bin                 # 不同os 版本的可执行文件
    │   ├── calicoctl                           
    │   ├── calicoctl-darwin-amd64
    │   └── calicoctl-windows-amd64.exe
    ├── images
    │   ├── calico-cni.tar
    │   ├── calico-kube-controllers.tar
    │   ├── calico-node.tar                     ## 容器运行时为host网络
    │   └── calico-typha.tar
    └── k8s-manifests
        ├── alp
        │   ├── istio-app-layer-policy.yaml
        │   ├── istio-inject-configmap-1.1.6.yaml
        │   └── istio-inject-configmap-1.1.7.yaml
        ├── calico-etcd.yaml
        ├── calico-policy-only.yaml
        ├── calico-typha.yaml
        ├── calico.yaml
        ├── calicoctl-etcd.yaml
        ├── calicoctl.yaml
        ├── canal-etcd.yaml
        ├── canal.yaml
        ├── crds.yaml
        ├── flannel-migration
        │   ├── calico.yaml
        │   └── migration-job.yaml
        └── rbac
            ├── rbac-etcd-calico.yaml
            ├── rbac-etcd-flannel.yaml
            ├── rbac-kdd-calico.yaml
            └── rbac-kdd-flannel.yaml

github 资源

    projectcalico/calico
    projectcalico/calicoctl
    projectcalico/felix
    projectcalico/cni-plugin
    projectcalico/node


![](/public/upload/network/calico_components.png)

calico 各个组件之间 通过etcd 相互通信，包括calicoctl

## 原理

### calico 架构

通过将整个互联网的可扩展 IP 网络原则压缩到数据中心级别。Calico 在每一个计算节点利用 Linux kernel 实现了一个高效的 vRouter 来负责数据转发 而每个 vRouter 通过 BGP 协议负责把自己上运行的 workload 的路由信息像整个 Calico 网络内传播 － 小规模部署可以直接互联，大规模下可通过指定的 BGP route reflector 来完成。

![](/public/upload/docker/calico_framework.png)

**通过将整个互联网的可扩展 IP 网络原则压缩到数据中心级别**。即将构建物理网络的设备、协议等 应用到数据中心网络

||传统互联网|calico|
|---|---|---|
|管理单位|自治系统||
|路由节点|路由器|主机上的路由表|
|连接节点|交换机|主机上的路由表|
|主机|主机|容器|

![](/public/upload/network/calico_network.png)

Calico 不使用隧道或 NAT 来实现转发，而是巧妙的把所有二三层流量转换成三层流量，并通过 host 上路由配置完成跨 Host 转发。PS：数据包的通信是利用linux 现有机制， calico的各个组件 通过操作linux 路由表、iptables等来控制数据包的流向，本身不接触数据包。**换句话说，某个时刻停掉calico组件，只要路由表记录还在，便不影响容器通信**。

### 报文流程

[Calico 网络通信原理揭秘](https://juejin.im/post/5d40f34d5188255d6f4faa87)

![](/public/upload/network/calico_connect.png)

当一个数据包的目的地址不是本机时，就会查询路由表，从路由表中查到网关后，它首先会通过 ARP 获得网关的 MAC 地址，然后在发出的网络数据包中将目标 MAC 改为网关的 MAC，而网关的 IP 地址不会出现在任何网络包头中。

    default         169.254.1.1     0.0.0.0         UG    0      0        0 eth0
    169.254.1.1     *               255.255.255.255 UH    0      0        0 eth0

从路由表可以知道 169.254.1.1 是容器的默认网关，169.254.1.1 是预留的本地 IP 网段，容器会查询168.254.1.1 的 MAC 地址，这个 ARP 请求发到哪里了呢？ eth0 是 veth pair 的一端，其对端是主机上 caliXXXX 命名的 interface，caliXXXX 没有ip只有一个无用的`ee:ee:ee:ee:ee:ee`，容器和主机所在网络不存在 169.254.1.1，容器想获取网关169.254.1.1的mac地址却找不到169.254.1.1，怎么办？ 实际上 Calico 利用了网卡的代理 ARP 功能。

    root$192.168.60.112:/# ip neigh
    169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee STALE
    192.168.60.112 dev eth0 lladdr ee:ee:ee:ee:ee:ee STALE


代理 ARP 是 ARP 协议的一个变种，当 ARP 请求目标跨网段时，网关设备收到此 ARP 请求，会用自己的 MAC 地址返回给请求者（PS：毕竟目标ip跨了网段，把目标ip的mac返回给主机也没用，查询某个网卡是否开始arp proxy`cat /proc/sys/net/ipv4/conf/califxx/proxy_arp`）。

1. Calico 通过一个巧妙的方法将 workload 的所有流量引导到一个特殊的网关 169.254.1.1，从而引流到主机的 calixxx 网络设备上，**最终将二三层流量全部转换成三层流量来转发**。

    |主机侧veth收到的数据包|源mac|目的mac|源ip|目的ip|差异|
    |---|---|---|---|---|---|
    |macvlan|容器|二层广播获取到目的容器的mac|容器|目的容器|数据包无论mac/ip都不是发给主机的|
    |calico|容器|calixx/`ee:ee:ee:ee:ee:ee`|容器|目的容器|数据包mac是发给主机的，根据ip做三层路由|
    |flannel|容器|flannel直接设置的目的mac|容器|目的容器||

2. 在主机上通过开启代理 ARP 功能来实现 ARP 应答，使得 ARP 广播被抑制在主机上，抑制了广播风暴，也不会有 ARP 表膨胀的问题。

容器的后续报文 IP 地址还是目的容器，但是 MAC 地址就变成了主机上对应caliXXXX的地址，也就是说所有的报文都会发给主机，然后主机根据路由表进行转发。caliXXXX 接收到报文后，报文的目的ip地址 10.20.72.131 匹配的是第二项（路由规则匹配的是一个网段），把 192.168.60.113 作为下一跳地址，并通过 em1 发出去。

    root$192.168.60.112:/# route
    default         gateway         0.0.0.0         UG    100    0        0 em1
    10.20.72.128    192.168.60.113         255.255.255.192 UG    0      0        0 em1
    10.20.227.129   0.0.0.0         255.255.255.255 UH    0      0        0 cali117717ca9c1


报文到达容器所在的主机 192.168.60.113 ，报文会匹配最后一个路由规则，这个规则匹配的是一个 IP 地址，而不是网段，也就是说主机上每个容器都会有一个对应的路由表项。报文发送到 cali52d6cb8b4e8 这个 veth pair，然后从另一端发送给容器，容器接收到报文之后，发送目的地址是自己，就做出应答，应答报文的返回路径和之前类似。

    root$192.168.60.113:/# route
    default         gateway         0.0.0.0         UG    100    0        0 em1
    10.20.227.128   192.168.60.112         255.255.255.192 UG    0      0        0 em1
    10.20.72.131    0.0.0.0         255.255.255.255 UH    0      0        0 cali52d6cb8b4e8


默认情况下，当网络中出现第一个容器时，calico 会为容器所在的节点分配一段子网（子网掩码为 /26，比如192.168.196.128/26），后续出现在该节点上的容器都从这个子网中分配 IP 地址。这样做的好处是能够缩减节点上的路由表的规模，按照这种方式节点上 `2^6` = 64 个 IP 地址只需要一个路由表项就行，而不是为每个 IP 单独创建一个路由表项。节点上创建的子网段可以在etcd 中 `/calico/ipam/v2/host/<node_name>/ipv4/block/` 看到。calico 还允许创建容器的时候指定 IP 地址，如果用户指定的 IP 地址不在节点分配的子网段中，calico 会专门为该地址添加一个 /32 的网段。

[Network Policy](https://feisky.gitbooks.io/kubernetes/concepts/network-policy.html)。当k8s想控制 namespace 之间是否可以 互通时，便要求网络组件能够根据 k8s 的指令做出反应。k8s 介入了网路，便有了和网络组件的沟通规范，就像docker和网络组件的接口一样。 正像calico github 上介绍的一样 Calico is an open source system enabling cloud native application connectivity and policy ，calico 除了支持 connectivity，还支持policy。

calico根据 profile/policy 生成对等的iptables rule， allow 或者 drop 流量，参见[Calico网络的原理、组网方式与使用](http://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2017/04/11/calico-usage.html)

## 与编排工具整合

### k8s安装步骤

k8s安装几个要点：

1. 必选先搞懂tls [ssl证书是什么东西](http://qiankunli.github.io/2017/06/11/ssl.html)
1. 搭建etcd集群 [如何搭建安全的ETCD集群](https://supereagle.github.io/2017/05/11/secure-etcd/)。下载tar.gz包，寻找etcd.service 模板，以systemctl启停etcd。安装etcd时不必拘泥后续对k8s和calico的支持，通用就行，忽略不必要的细节。
2. 对于master 运行scheduler、controller-manager、apiserver 可以直接用容器的方式运行（不建议这种方式），也可以下载二进制文件执行运行（寻找相关xx.service模板，以systemctl启停）。

参考文章：[Kubernetes 1.8.x 全手动安装教程](https://www.kubernetes.org.cn/3096.html)

## bgp

### bpg 原理

[calico初识](http://qiankunli.github.io/2018/02/28/bgp.html)

calico 为什么使用BGP [Why BGP?](https://www.projectcalico.org/why-bgp/) In the Calico design, this would equate to tens of thousands of routers, and potentially millions of routes or end points. These numbers are not consistent with using an IGP, but do fit in the envelope for BGP, especially when we use route reflection to improve the router scaling number. calico 假设 网络中有上万个 routers，这个量级下IGP 效率不行。

Each endpoint（也就是容器的cali0） can only communicate through its local vRouter（容器所在host）, and the first and last hop in any Calico packet flow is an IP router hop through a vRouter（也就是cali0 只跟 host 交互）. Each vRouter announces all of the endpoints it is attached to to all the other vRouters and other routers on the infrastructure fabric, using BGP, usually with BGP route reflectors to increase scale. （vRouter 或运行 route reflectors服务的 route彼此会交流 路由信息）

一个网络凭空多了许多vRouter，需要与其它vRouter 通过bgp 同步信息，

根据AS 的不同划分方式（共用一个AS/每个机架交换机一个AS/一个node一个AS，AS 内 ibgp，AS间 ebgp，ibgp 和 ebgp 的speake 路由通告规则不同），有多种组网模型，都可以实现分发路由的效果，只是适应的网络规模、架构等有所不同[IP Interconnect Fabrics in Calico](https://docs.projectcalico.org/v2.6/reference/private-cloud/l3-interconnect-fabric#fn:1)

`calicoctl node status` 列出当前node 可以沟通路由规则的peer。 

[Dive into Calico - IP Interconnect Fabrics](http://hustcat.github.io/dive-into-calico/)

### 数据中心 calico bgp路由同步策略

[Basic Calico architecture overview](https://docs.projectcalico.org/v2.6/reference/private-cloud/l3-interconnect-fabric#fn:1)

## 使用

### calicoctl 使用

本节有calicoctl 1.6.3 为准

1. The calicoctl command line interface provides a number of resource management commands to allow you to create, modify, delete, and view the different Calico resources.
2. calicoctl 的command 分为三个部分：

	* Resource的增删改查，包括create、replace、apply、delete、get
	* node，start and check calico/node container.
	* config
	* ipam, ip 地址管理，只有两个command： release、show。release 用来手动释放一个已分配的ip

问题来了， calico 中的resource 说的啥东东？[Resource Definitions](https://docs.projectcalico.org/v2.6/reference/calicoctl/resources/)

1. bgp peer
2. host endpoint
3. ip pool
4. node，quay.io/calico/node 容器启动时自动创建
5. policy,
6. profile, Calico uses an identically（同一的） named profile to represent each Docker network.calico 的每个网络都有一个同名的 profile，profile 中定义了该网络的 policy。 profile 的两个关键配置 ingress egress，即描述了哪些流量可以进来，哪些流量可以出去。
7. workload endpoint


**profile 和 policy 换一种方式描述 iptables的意思（实际效果仍然是iptables 实现，并且都采用了rule 的方式）**，描述了规则（主要是 ingress 和 egress）以及 应用规则的 endpoint。两者的区别是：

1. profile与network 同名，profile的 ingress 和 egress 自动应用到 network 中的 所有endpoint上。 policy的 ingress 和 egress 应用到 符合 selector所定义的规则的 endpoint 上。
2. profile 自动创建，policy 手动创建
3. profile 算是一种 特殊的 policy

The calicoctl commands for resource management (create, apply, delete, replace, get) all take resource manifests as input. 有点类似k8s，kubectl 操作的时候指定的是 json/yaml

	apiVersion: v1
	kind: <type of resource>
	metadata:
	  # Identifying information
	  name: <name of resource>
	  ...
	spec:
	  # Specification of the resource
	  ... 


By default, Calico blocks all traffic unless it has been explicitly allowed through configuration of the globally defined policy which uses selectors to determine which subset of the policy is applied to each container based on their labels. （calico 默认会阻止所有流量，除非明确允许）

### 排查——node status 有问题

containerA跨主机ping hostB上的containerB，不通，检查步骤

1. tcpdump(`tcpdump -nn -i 网卡名 -e`) 判断 hostA 网卡是否收到包
2. 检查 hostA 路由规则
3. tcpdump 判断 hostB 网卡是否收到包
4. 检查 hostA 路由规则

已知原因:

`calicoctl node status` 某个节点 状态 不是up

	IPv4 BGP status
	+---------------+-------------------+-------+----------+--------------------------------+
	| PEER ADDRESS  |     PEER TYPE     | STATE |  SINCE   |              INFO              |
	+---------------+-------------------+-------+----------+--------------------------------+
	| 192.168.60.42 | node-to-node mesh | start | 06:03:39 | Active Socket: Connection      |
	|               |                   |       |          | refused                        |
	| 192.168.60.83 | node-to-node mesh | wait  | 06:03:40 | Established                    |
	+---------------+-------------------+-------+----------+--------------------------------+