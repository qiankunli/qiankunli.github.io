---

layout: post
title: go gc
category: 技术
tags: Go
keywords: Go gc

---

## 前言

* TOC
{:toc}

[万字长文深入浅出 Golang Runtime](https://zhuanlan.zhihu.com/p/95056679)

现代计算机语言大多数都带有自动内存管理功能，也就是垃圾收集（GC）。程序可以使用堆中的内存，但我们没必要手工去释放。垃圾收集器可以知道哪些内存是垃圾，然后归还给操作系统。垃圾收集包括标记-清除、停止-拷贝两大类算法，停止-拷贝算法被认为是最快的垃圾收集算法，但停止-拷贝算法有缺陷STW（Stop-The-World）。 **在自动内存管理领域的一个研究的重点，就是如何缩短这种停顿时间**。以 Go 语言为例，它的停顿时间从早期的几十毫秒，已经降低到了几毫秒。甚至有一些激进的算法，力图实现不用停顿。增量收集和并发收集算法，就是在这方面的有益探索。

增量收集可以每次只回收部分对象，没必要一次把活干完，从而减少停顿。并发收集就是在不影响程序执行的情况下，并发地执行垃圾收集工作。

为了讨论增量和并发收集算法，我们定义两个角色：一个是收集器（Collector），负责垃圾收集；一个是变异器/应用程序（Mutator），它会造成可达对象的改变。

## 三色标记法

采取 STW 这样凶残的策略，主要还是防止 mutator 在 GC 的时候捣乱——这跟你用扫地机器人的时候先把狗（Mutator/Application）先锁起来，等房子全部打扫完再把狗放开 的道理是一样的（Stop The Dog）。

[新一代垃圾回收器ZGC的探索与实践](https://mp.weixin.qq.com/s/ag5u2EPObx7bZr7hkcrOTg) **与jvm ZGC 非常类似**。自己的理解：
1. java对象头信息是跟对象自身定义的数据结构无关的，**这些信息所记录的状态是用于JVM对对象的管理的**（比如并发访问和gc）。
2. gc root 是一些固定特点的对象，一直存在。gc过程可以看做给 gc root加子节点的过程，最后得出一棵树（可达对象在“物理平面”是犬牙交错的），节点有两种状态，在不在树上（可达不可达，对象头mark word 有专门字段），在树上的节点不会被回收。事实上树并不存在（否则对象头 就得有字段表示子节点了），只是gc 线程遍历轨迹的一种表示。
3. 抛开gc 线程和应用线程，线程A和线程B竞争访问同一个对象，可以线程安全的一个底层机制就是，对象头 里有一个mark word 标记了对象是线程A的“人”，当线程B 从对象 mark word 中发现 对象“名花有主”了，就会放弃操作 对象，等待。
4. gc 线程和 应用线程 也是如此，之前 gc 和 应用线程没有 沟通机制，所以gc 干活儿的时候，应用线程就得 “歇着”。涂色 本质上 是给了 应用线程一种权力，在对象上做标记（就像对象mark word上的 线程标识符一样），告诉 gc 线程 这个对象 “我罩着了”，gc 线程便不会回收了。


### 文章一

[Go 垃圾回收（三）——三色标记法是什么鬼？](https://zhuanlan.zhihu.com/p/105495961/)

在三色标记法之前有一个算法叫 Mark-And-Sweep（标记清扫），这个算法就是严格按照追踪式算法的思路来实现的。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是 0，如果发现对象是可达的就会置为 1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未被标记的对象统一清理，再次把所有的标记位设置成 0 方便下次清理。这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步进行 GC 操作。因为在不同阶段标记清扫法的标志位 0 和 1 有不同的含义（比如0 可能是未被清理 也可能是清理完毕了？），那么**新增的对象无论标记为  什么都有可能意外删除这个对象**。对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 GC 运行时程序长时间挂起的问题，那就三色标记法。

相比传统的标记清扫算法，**三色标记最大的好处是可以异步执行**，从而可以以中断时间极少的代价或者完全没有中断来进行整个 GC。三色标记法很简单。
1. 首先将对象用三种颜色表示，分别是白色、灰色和黑色。最开始所有对象都是白色的，然后把其中**全局变量和函数栈里的对象**置为灰色。
2. 第二步把灰色的对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。
3. 等发现没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。

![](/public/upload/go/three_color_marking.gif)

三色标记法**因为多了一个白色的状态来存放不确定的对象，所以可以异步地执行**。当然异步执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。


[Go 垃圾回收（四）——一次完整的回收](https://zhuanlan.zhihu.com/p/105571503)

三色标记法是一种可以并发执行的算法。所以**在运行过程中程序的函数栈内可能会有新分配的对象，那么这些对象该怎么通知到 GC，怎么给他们着色呢？**这个时候就需要我们的 Write Barrier 出马了。Write Barrier 主要做这样一件事情，**修改原先的写逻辑，然后在对象新增的同时给它着色，并且着色为”灰色“**。因此打开了 Write Barrier 可以保证了三色标记法在并发下安全正确地运行。

 Go 的 GC 有且只会有一个参数进行调优，也就是我们所说的 GOGC，目的是为了防止大家在一大堆调优参数中摸不着头脑。 默认值是 100。这个 100 表示当内存的增加值小于等于 100% 时会强制进行一次垃圾回收。我们可以通过环境变量将这个值修改成 200，表示当内存增加 200% 时强制进行垃圾回收。或者将这个值设置为负数表示不进行垃圾回收。

### 文章二

[V8 增量 GC 之三色标记](https://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/)

着色还可以辅助gc 线程的执行：因为增量回收是并发的（concurrent），因此它的过程像上图一样（可以想象一下 CPU 的时间片轮转），这就意味着 GC 可能被随时暂停、重启，因此暂停时需要保存当时的扫描结果，等下一波 GC 来之后还能继续启动。而双色标记实际上**仅仅是对扫描结果的描述**：非黑即白，但忽略了**对扫描进行状态的描述**：这个点的子节点扫完了没有？

为了处理这种情况，Dijkstra 引入了另外一种颜色：灰色。

1. 灰色，它表示这个节点被 Root 引用到，但子节点我还没处理；
2. 黑色的意思就变为：这个节点被 Root 引用到，而且子节点都已经标记完成。
3. 白色表示，算法还没有访问的对象

用三色标记法来分析的话，你会发现前面的算法有两个特点：

1. 不会有黑色对象指向白色对象，因为黑色对象都已经被扫描完毕了
2. 每一个灰色对象都处于Collector/GC的待处理工作区中，比如在标记-除算法的 todo 列表中（标记算法就是一个图的广度优先遍历过程，需要一个队列的支持）。

我们发现，**只要保证这两个特点一直成立，那么Collector/GC和Mutator/Application就可以一起工作，互不干扰**，从而实现增量收集或并发收集。

1. Collector/GC线程得到cpu后，GC只需要处理灰色节点即可。当图中没有灰色节点时，便是整个图标记完成之时，就可以进行清理工作了。
2. Mutator/Application 可以访问 黑色或白色节点（存疑）

如何保证上面两个特点一直成立？比如，如果Mutator/Application 要在一个黑色对象 a 里存储一个指针 b，把 a 涂成灰色或者把 b 涂成灰色，都会保持上面两条的成立。或者当Mutator/Application 要读取一个白色指针 a 的时候，就把它涂成灰色，这样的话也不会违背上面两条。PS：**不管如何， gc 期间，Mutator/Application 访问的对象就是活跃对象，就要涂成灰色，就不能被回收**。

不同的算法会采取不同的策略，但无论采取哪种算法，Collector/GC和Mutator/Application都是通过下面三种机制来协作：

1. 读屏障（read barrier 或 load barrier）。在 load 指令（从内存到寄存器）之后立即执行的一小段代码，用于维护垃圾收集所需的数据。包括把内存对象涂成正确的颜色，并保证所有灰色对象都在算法的工作区里。
2. 写屏障（write barrier 或 store barrier）。在 store 指令（从寄存器到内存）之前执行的一小段代码，也要为垃圾收集做点儿工作。
3. 安全点（safepoint）。安全点是代码中的一些点，在这些点上，指针的值是可以安全地修改的。有时，你修改指针的值是有问题的，比如正在做一个大的数组的拷贝，拷到一半，你把数组的地址改了，这就有问题。所以安全点一般都在方法调用、循环跳转、异常跳转等地方。

三色标记主要是为了解决传统双色标记过程无法分片的问题（或者说STW是 串行执行的，不需要分片），有了三色标记，Collector/GC线程便可以暂停、重启，变成跟 mutator并发的方式来运行；

[三色标记法是什么？](https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.4.GC-GC.md)三色标记过程其实是一个波面不断前进的过程。

![](/public/upload/basic/tri_color_ripple.png)

就物理位置来说，三个颜色的对象是“犬牙交错”的，通过标记颜色，使其变成了几块“泾渭分明”的区域。


## Go比Java产生更少的内存垃圾

**Go的对象(即struct类型)是可以分配在栈上的**。Go会在编译时做静态逃逸分析(Escape Analysis), 如果发现某个对象并没有逃出当前作用域，则会将对象分配在栈上而不是堆上，从而减轻了GC压力。其实JVM也有逃逸分析，但与Go不同的是Java无法在编译时做这项工作，分析是在运行时完成的，这样做一是会占用更多的CPU时间，二是不可能会把所有未逃逸的对象都优化到栈中。

## 整体实现

[Golang源码探索(三) GC的实现原理](https://www.cnblogs.com/zkweb/p/7880099.html)GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.

首先GC有四个阶段, 它们分别是:

1. Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC
2. Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收
3. Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)
4. Sweep: 按标记结果清扫span

在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.
1. 标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.
2. 清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒.

## 源码入口

`$GOROOT/src/runtime/mgc.go` go触发gc会从gcStart函数开始

## GC友好的代码
避免内存分配和赋值
1. 尽量使用引用传递
2. 初始化至合适的大小
3. 复用内存