---

layout: post
title: 做配置中心要想好的几个基本问题
category: 技术
tags: Architecture
keywords: config center

---

## 简介

名词解释

||说明|
|---|---|
|配置中心|支持kv配置的crud、应用接入等|
|客户端配置**（下发）**中心|app启动时，访问客户端配置中心，拉取一系列开关、数值等配置|
|服务端配置**（下发）**中心|业务模块启动时，访问服务端配置中心，拉取一系列开关、数值等配置并注册监听事件|

## 配置中心与配置中心对客户端和服务端的支持问题

起初，笔者的任务是实现一个客户端配置中心，后来又新增了对服务端配置中心的支持。所以，最初的实现上，配置中心，客户端配置中心，服务端配置中心，是混杂在一起的。

但在一些具体的特性上，三者是有所不同的。

1. 配置的组织，用户通常有批量处理配置的需求，那么批量的粒度是什么？同时，在某个粒度之上，通常附属以权限控制等信息。

	||组织维度|
	|---|---|
	|配置中心|大体上按接入的应用划分，一个应用配置过多时，可提供类似“文件夹”的概念，一个“文件夹”包括额定数量的配置|
	|客户端配置中心|应用-分组-配置|
	|服务端配置中心|应用-环境-分组-配置|
	
2. 下发的方式

	||下方方式|
	|---|---|
	|配置中心|jar、rpc、restful接口，供业务方主动调用|
	|客户端配置中心|app启动时，访问http接口。配置更改时，推送（如果有长连接基础设施的话）。是否支持增量下发|
	|服务端配置中心|client与server间轮询或推送配置。有时要求支持灰度下发，但一般无增量下发需求|
	
3. 权限控制

	||表现形式|
	|---|---|
	|配置中心|上层业务模块访问配置前，向配置中心申请token|
	|客户端配置中心/服务端配置中心|某产品经理被赋予操作某app广告模块的权限，以此该产品经理可以在定制化界面上查看和操作配置|
	
如果将配置中心、客户端配置中心、服务端配置中心混杂在一起，因其主要的相似性，代码可以勉强实现，但比较复杂，改动起来，牵涉也比较多。比如，如果配置中心只是简单地负责key value存储，则实现不同环境（test、product）的配置迁移时就非常方便。反之，则要考虑各种场景。

## 配置中心的对外接口问题

以新增配置为例，实际的实现中，新增配置完毕后，通常不意味着新增的配置能够立即对客户端或业务模块可见。比如对于客户端配置中心，此配置或许还需要经过审核与发布流程。如果将审核发布流程做在配置中心里，那么业务方通过接口新增配置时，add接口是自动审核？还是新增审核接口，然后由用户手动调用？带来的另一个问题是：对于无需此流程的上层业务模块（如果有的话），便意味着不便与难以理解。

可见，配置中心适合单纯的作为一个存储组件，支持配置的crud，其它的事情交给上层业务来处理。类似的api接口可以参考[Apollo开放平台](https://github.com/ctripcorp/apollo/wiki/Apollo%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0)

具体接口可以提供restful api和rpc等选项，甚至封装jdbc的jar。

## 业务和配置中心的结合问题

### 利用配置中心做配置下发

如果配置中心只是单纯的作为一个存储组件？那么将配置（通常表现为key value）存储在配置中心，与存储在redis、db中有何不同？笔者认为的重点是：**支持配置的自动下发。**

也就是说，配置中心和客户端配置中心、服务端配置中心最好分开开发，但配置中心作用的发挥，却离不开配置中心客户端与服务端的支持。

从另一个角度看，配置中心既然作为存储组件，那么业务模块可否将所有配置都存储在配置中心上呢？当然可以。这样一来，业务模块负责定制化业务界面，将用户输入encode为key value交由配置中心存储。同时利用配置中心的下发功能，将下发的key value decode为业务数据，进行下一步处理。

### 操作界面是否共用的问题

配置中心一般会提供一个ui界面以方便手动的crud，既然选择将业务模块数据存入配置中心，那么是否可以直接在配置中心操作业务模块配置呢？笔者的教训是，可以，但大多数时候是受限的。

笔者曾试图将一些复杂的数据结构交给配置中心来直接存储，比如

	<a id="a_id_1">
		<b name=""/>
		<c>
			<d id="d_id_1" name="" value=""/>
			<d id="d_id_2" name="" value=""/>
		</c>
	<a>
	
根据配置中心kv的存储方式，有以下方式可以存储上述数据

1. 将xml序列化为model，配置中心新增一个key，value为model json后的字符串
2. 创建以下几个key

	* `a.id`
	* `a.a_id_1.b.name`
	* `a.a_id_1.c.d.id`
	* `a.a_id_1.c.d.d_id_1.name`
	* `a.a_id_1.c.d.d_id_1.value`

对于后一种方式，一个复杂结构转换为一个kv set，总是可以想办法做到。但考虑到这样的配置晦涩难懂，用户很难通过直接操作配置中心来设置业务配置。如此一来，共享界面的意义便不复存在，同时增加了配置下发的难度。

因此，笔者还是建议做定制化的界面开发，配置中心的ui界面，只当做数据展示就好了。

![](/public/upload/architecture/config_center_framework.png)

## 配置中心与abtest的结合问题

笔者在设计配置中心之初，便有支持abtest的需求，因此在最初实现的版本中，除了混杂配置中心、客户端配置中心、服务端配置中心外，还夹杂有abtest的实现。一个直观的表现：有一些数据库表，其职责便是将abtest数据与配置中心数据关联起来。

abtest也分为面向客户端和服务端，借助于配置中心的下发通道，将abtest数据下发到客户端和服务端，然后由客户端和服务端计算得出AB对应的行为。这种行为的表现形式：

1. 某个参数的值：选择A or 选择 B
2. 直接执行某个动作

而第二种方式可以由第一种方式扩展来达到同样的效果。

笔者在实现时，想当然的把 abtest ”参数“ 和配置中心”配置“ 当作一回事，最终配置中心和abtest便深度耦合在了一起：abtest的判断数据存在abtest自有的库中，”参数“数据则存储在配合中心中。更进一步，为了减少客户端开发的工作，客户端配置中心在配置下发时，便已根据客户端的用户数据做好了配置的匹配工作。代价是，考虑到对增量下发的支持，增量下发、abtest、客户端配置中心三块逻辑的代码就会高度耦合。

所以理想状态

![](/public/upload/architecture/config_center_abtest.png)

1. abtest通过定制化界面，读取配置中心数据，负责abtest数据的生成并存入配置中心。abtest “参数”和 配置中心“配置” 可以关联，但这种关联只是以tag等方式描述。
2. 客户端配置中心无差别的下发配置数据和abtest数据
3. 由客户端做abtest数据与配置数据的合并

## 配置中心的多环境支持问题

1. 多环境共用界面。配置通常具备一定的组织关系，比如以`app==> group ==> item`多环境集成在一起时，新增一个app，则三个环境都新增一个app，省去了事后同步组织关系的麻烦。对于配置的值，则各个环境依旧保持独立。
2. 共用界面对系统设计的影响 ==> api接口的提供
3. 两类数据库表：

	* 每个环境独有的
	* 多个环境共用的表，比如账号权限表。PS，对于一些唯一name的domain，在引用domain记录时，在某些场景下，使用name关联比id更好些。

	独有和公有有一个边界，那就是每个环境独有的数据表可以形成一个最小的可用配置中心。

4. 账号权限系统设计。
5. 
## 小结

根据笔者一些片面的实践，本文尝试理清配置中心、下发系统及其与衍生业务的关系。在实践过程中，往往难以按照理想状态来实施，都是根据初始的任务要求，进行了一定程度的耦合（妥协）。比如携程的[ctripcorp/apollo](https://github.com/ctripcorp/apollo)即侧重于服务端配置中心。

现在看来，笔者实践的过程中，主要有以下失误：

1. 配置中心、abtest耦合开发。或者说，当时根本就没有理清楚各个业务模块的关系。
2. 过分看重增量下发，后来发现，在一两年内都没有实际的需要。并且随着客户端组件化的推进，基本没有需求。
	

