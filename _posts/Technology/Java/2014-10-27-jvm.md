---
layout: post
title: jvm小结
category: 技术
tags: Java
keywords: JAVA JVM
---

## 前言

本文主要是对《深入理解java虚拟机》，欢迎大家指正！


## JVM内存区域新画法 ##

我觉得《深入理解java虚拟机》，那张jvm内存区域图只是体现了内存区域的组成，我这个可能更好点：

![Alt text](/public/upload/java/jvm_memory.png)

一个cpu对应一个线程，我们从cpu的根据pc指向的指令的一次执行开始：

1. cpu执行pc指向方法区的指令
2. 指令=操作码+操作数，jvm的指令执行是基于栈的，所以需要从栈帧中的“栈”区域获取操作数，栈的操作数从栈帧中的“局部变量表”和堆中的对象实例数据得到。
3. 当在一个方法中调用新的方法时，根据栈帧中的对象引用找到对象在堆中的实例数据，进而根据对象实例数据中的方法表部分找到方法在方法区中的地址。根据方法区中的数据在当前线程私有区域创建新的栈帧，切换PC，开始新的执行。

### OOM

不同的区域存储不同性质的数据，除了程序计数器区域不会OOM外，其它的都有可能因为存储本区域数据过多而OOM。

## 垃圾收集算法

### 如何判断对象已经死亡

说白了，判断还有“引用”引用它么？

1. 引用计数法

    记录对象被引用的次数
  
2. 可达性分析算法

    以一系列GC Roots对象作为起点，从这写节点向下检索，当GC Roots到这些对象不可达时，则证明此对象是不可用的。

### 回收已死对象所占内存区域

当我们知道哪些对象可以回收时，它们分散在堆的各个地方，如何提高回收效率呢？一次回收完成后，理想状态是：内存是“整齐”的，活着的在一边，空闲的在一边。

1. 标记-清除算法

    - 实现： 第一遍，标记堆中哪些对象需要被回收；第二遍，回收被标记的对象。
    - 特点：效率不高，一次回收后，堆区碎片化

2. 复制算法

    - 实现：将区域分成两块（或多块），先紧着一块使用，这块用完后，将活着的对象复制到另一块，然后回收这一整块。
    - 特点：一部分区域会被浪费，如果对象都是“朝生夕死”的，则非常适合
3. 标记-整理算法

    - 实现：让所有活着的对象都向边界一端移动，清理端边界以外的堆区域
4. 分代收集算法

    - 实现：将堆区根据对象生存期分为几块，比如分为新生代和老年代，新生代采用“复制算法”，老年代采用“标记-清理”或“标记-整理”算法。


## 一个计算机可以运行多少线程

[并发之痛 Thread，Goroutine，Actor](http://lenix.applinzi.com/archives/2945)

1. 内存：每个线程都需要一个栈（Stack）空间来保存挂起（suspending）时的状态。Java的栈空间（64位VM）默认是1024k，不算别的内存，只是栈空间，启动1024个线程就要1G内存。虽然可以用-Xss参数控制
2. 调度成本：在个人电脑上做的一个非严格测试，模拟两个线程互相唤醒轮流挂起，线程切换成本大约6000纳秒/次。这个还没考虑栈空间大小的影响。国外一篇论文专门分析线程切换的成本，基本上得出的结论是**切换成本和栈空间使用大小直接相关**。

来一句废话就是：如果线程是一直处于运行状态，我们只需设置和CPU核数相等的线程数即可。


## 类加载

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转化解析和初始化，最终形成可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。

类加载器的双亲委派模型：
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器，类加载器间的父子关系不会以继承关系实现，而是以组合的方式来复用父类加载的代码。

双亲委派模型的工作过程：
当一个类加载器收到类加载请求的时候，它会首先把这个请求委托给父类加载器去执行，因此所有的类加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器也无法找到时才会交给自己去加载。

双亲委派模型的关键就是定义了类的加载过程，先尝试用父类加载器加载，再使用自定义加载器加载，以确保关键的类不被篡改。

使用场景：

1. 热部署
2. 代码加密
3. 类层次划分

### 小结

知道垃圾回收的机理没有意义，有意义的是

1. 观察所做系统的对象生存时间，从而更改jvm垃圾收集算法配置以提高效率，这个比较高大上，一般人干不了
2. 在程序中留点心，尽量减少“无引用”对象的产生。比如，尽量不要在for循环中创建对象。