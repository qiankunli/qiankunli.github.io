---
layout: post
title: 多线程
category: 技术
tags: Java
keywords: 多线程 JAVA
---

## 前言 

关于多线程这块，要是看书，一会儿说一个类，一会儿讲一个知识点，感觉很快就被带入细节中。所以本篇讲讲我对java多线程的一个初略理解，应该讲的都是“人话”。

## 操作系统中的线程

### 单线程

我们如何影响线程的行为呢？

1. 创建它：继承Thread，实现Runnable，实现TimerTask（现在不推荐）
2. 启动它：start
3. 暂停它：sleep
4. 停止它：interrupt，注意这种停止并不是抢占式的。


### 多线程

多个线程同时执行时，有以下几种可能：

1. 乱序执行

    ![Alt text](/public/upload/threads_wuxu.png)    
2. 协作执行（部分有序）

    - 某一部分不能被中断
 
        ![Alt text](/public/upload/threads_bufenyouxu.png)  
      
    - 部分有序的
  
        ![Alt text](/public/upload/threads_bufenyouxu2.png)  
   

3. 有序执行（执行完一个，再执行另一个）
    
    比如java的join方法

So，从乱序、部分有序、到有序执行，这是一个渐近的过程。这也从另一个侧面证明，java的多线程程序，本质上就是在线性程序上加了一些限定。这比起现在新兴的、原生支持多核和并行化的编程语言（比如Go语言），逊色不少。

### 锁与线程同步

线程的运行需要一定的资源，硬件如打印机、磁盘、数据库和显示屏等，软件如变量等数据结构（其实也是某个特定的内存资源），因为大家都在使用，所以并不能确保资源“申请即得到（这里描述为“可以访问”）”，“得到即可用（这里描述为可以使用）”。

硬件资源的分配，由操作系统提供。而软件资源的分配与协调则由开发人员通过代码主动控制。

锁与同步，本质上都是通过程序，人为的改变线程的状态（由运行改为挂起），**线程的挂起和恢复采用同样的机制**：当前线程检测无法访问（或使用）时被挂起，由别的线程执行完毕后触发 恢复被挂起的线程。

1. 锁只是负责资源的独占访问，但该资源是否**语义上可用**，并不保证。比如现在没有其他线程访问资源池，消费者线程可以访问资源池，但资源池没有资源时，消费者线程也是需要等待的。因而锁的应用场景比较通用和固定，程序语言可以方便的进行抽象。比如java提供一个synchronized关键字便包装了线程申请锁，（锁被占用时挂起），锁被其他线程释放时，触发被该锁挂起的线程执行  的过程。（这个包装给我带来了很大困惑，让我误以为锁和线程同步是两个事情，其实本质是一样的）
2. 线程同步，确保了线程在语义上可以使用共享资源。当线程访问共享资源，检测语义不满足（标志位被占用），会被挂起，需要协作线程满足语义后，触发当前线程的继续执行。但因为应用场景多种多样，所以由开发人员手动写入线程挂起和恢复代码。

## java提供的多线程

1. 从代码的感觉上讲，我经常很困惑，比如

        class ThreadA extends Thread{
            public void run(){
                codeA;
                threadb.join();    //threadB.join()的意思是向threadB发送jion消息，加入到当前线程中来，完事执行codeB;
                codeB;
            }
        }
        class MyThread extends Thread{
            public void run(){
                synchronized(b){
                     xx
                     b.wait();    //此处是将当前线程挂起
                }
            }
        }

我的直观感觉是：挂起当前线程，当前线程应提供一个方法，比如wait，然后thread.wait()。而事实是通过锁对象调用wait方法来做到的，也就是通过另一个对象的操作改变了当前对象状态，我在**ThreadLocal小结**中也提到了类似的情形。原因便是：任何一个方法在执行时都可以通过Thread.currentThread()获取当前线程对象，从而通过线程对象调用线程方法对线程进行一定操作。

**找时间看看wait源码**

## java编写并发程序的历程

1. 使用原始的wait和notify等方法，或者使用lock和condition对象的，这些是细粒度的、基本的进程控制。其实就是在线性程序的基础上确保了线程安全，对程序员能力要求较高。
2. jkd1.5和jdk1.6提动了concurrent包，提供了执行器，高效和并发的数据容器，原子变量和多种锁，从某种程度上降低了编写并发程序的难度。
3. jdk1.7提供ForkJoinTask支持，还未详细了解，估计类似于MapReduce，其本身就是立足于编写可并行执行程序的。
