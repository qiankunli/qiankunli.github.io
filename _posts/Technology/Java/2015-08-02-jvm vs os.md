---

layout: post
title: class jvm VS 可执行文件 linux
category: 技术
tags: Java
keywords: jvm

---

## 前言（未完待续）

在linux中，可执行文件没有唯一的后缀名，本文以"可执行文件"统称 

jvm体系的class文件对应于linux中的可执行文件，jvm对应于linux os，两者有很多相象的地方。但毕竟机理不同，class文件和可执行文件的不同正是两个os机理不同的反映。

而本质上的不同，则要追溯到java的起源：面向网络，为了让“可执行文件”在网络上传输并在不同的系统上执行，发散出很多机制。

本文以jvm为“主场”，以传统os为“客场”，在讲述jvm的过程中，对比jvm与传统os的不同。

## jvm 

学习jvm主要有以下几大块

1. class文件格式
2. class文件加载
3. jvm内存模型（内存回收）

    由java区域和native区域组成，每个区域分为堆栈两个部分。java区域中，还有一个永久代，存储共享的，生命周期基本上跟java进程一样的数据。（永久代在有的jvm实现产品中没有）   
    
4. jvm对象模型 
5. jvm解释器（字节码指令执行）


类似于《程序员的自我修养》的书在阐述传统os时，并没有“内存模型”之类的术语（只会讲述通过分段和分页来管理内存的基本原理）。我们总是以传统os的眼光来审视jvm这个虚拟的os，反过来讲，以jvm（几大块的组成）来看待传统可执行文件的文件格式、加载和执行过程，也是非常有意义的。

## 内存模型和解释器

java是一种跨平台的编程语言，为了跨平台，jvm抽象出了一套内存模型和基于栈的解释器，进而创建一套在模型基础上运行的字节码指令。（这也是本文不像其它书籍一样先从"class文件格式"讲起的原因）

1. 为了跨平台，不能假定平台特性，因此抽象出一个新的层次来屏蔽平台特性，因此推出了基于栈的解释器，与以往基于寄存器的cpu执行有所区别。
2. `字节码指令 = 操作码 + 操作数`,（操作数可以是立即数，可以存在栈中，也可以是指向堆的引用（引用存在栈中）） `传统的指令 = 操作码 + 操作数`,（操作数据可以是立即数，可以存在寄存器中，也可以是指向内存的引用）此处jvm的栈，说的是栈帧，跟传统的栈还是有不同的，**粗略的讲，我们可以说在jvm体系中，用栈取代了原来寄存器的功能。**这句话的不准确在于，对于传统cpu执行，线程之间共用的寄存器，只不过在线程切换时，寄存器数据会被保存在线程私有的空间（线程数据所在内存页）中。而在jvm体系中，每个线程的栈空间是私有的，一直存在栈中，轮到某个线程执行时，线程直接访问栈区域中对应自己的部分即可（因而省了切换的开销，谁让jvm内存模型属于更上一层的模型呢）。（此处描述有臆想的成分，待补充）
3. 传统os的指令执行，本质上借助了pcb（进程控制块或线程控制块），pcb保存了现场环境，现场环境恢复后，cpu按照pc的执行即可。而jvm的执行则是，线程被调度执行时，根据pc执行方法区中的指令。（进入和推出方法，会伴随着栈帧的创建和销毁）（待补充）

## 堆的管理

其实跟内存的碎片管理是一样的。可执行文件的加载因为程序大小的不一致，导致内存分配的碎片化。对象的加载，因为对象大小的不同，导致堆的碎片化。

双方有些共同点

1. 都不按实际的大小分，可执行文件会占用整数个页，对象占用的空间则会补齐（整字长倍）。
2. 在内存中都有“热门”和“冷门”的区别，有的对象（或可执行文件）经常被调用，有些用过即不用了。因此大家想了不同的办法解决，传统os选择“向外扩展”，把暂时不用的扔到硬盘上。jvm选择对内区别对待，堆区域分代。
3. 程序和可执行文件  本身，都将“方法之类”的数据共享，“数据之类”的数据保存多份。

## class文件格式

因为指令中包含了操作数，可执行文件不只是指令的堆砌。

操作数大部分是地址引用，寄存器（或栈）成了存储引用的地方，作为cpu和内存的“中转站”。还有一些符号引用，需要在指令之前，描述这些符号引用。

class文件中包含方法和属性信息，这些数据为反射机制提供的基础。

## class文件的加载

加载的本质，从磁盘上加载，得到的是一个字节数组，然后按照自己的内存模型，把字节数组中对应的数据放到对应的地方。






