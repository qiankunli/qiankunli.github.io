---

layout: post
title: Future
category: 技术
tags: Java
keywords: future

---

## 简介

Future jdk源码中的接口定义与描述

    interface Future<T>{
         boolean cancel(boolean mayInterruptIfRunning);
         boolean isCancelled();
         boolean isDone();
         V get() throws InterruptedException, ExecutionException;
         V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
    }
    
A Future represents the result of an asynchronous computation.  Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation.  **The result can only be retrieved using method get** when the computation has completed, blocking if necessary until it is ready.  Cancellation is performed by the cancel method.  Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled.

## 任务的取消、关闭和结果的访问
    
《java并发编程实战》第二部分的着重讲了任务的执行和**取消与关闭**，我们常关注如何启动线程。几个执行体如何触发执行

1. Runnable，`new Thread(xx).start()`没办法直接到拿到运算结果
2. Callable，`ExecutorService.submit(xx)`通过返回值拿到返回结果
3. FutureTask，`new Thread(xx).start`通过get方法拿到返回结果

前两者只有thread运行完毕才知道（或能够访问）运算任务的结果，而FutureTask的返回结果通过get方法一封装，我们就有机会在任务的开始前、开始后和结束后访问运算结果，毕竟调用方并不知道任务现在在哪个阶段，这个给了调用方代码很大的灵活性。

任务的取消和关闭也是如此。**我们理解一个Future的关键，一个切入点就是它如何取消一个线程的执行。**

取消一个任务本质上两个方法（当然，任务已经结束就无法取消了）：

1. 线程run方法里有interrupt判断，在另外一个地方拿到线程的引用thread，然后`thread.interrupt()`

        class XXThread extends Thread{
            void run(){
                try{
                    while(!Thread.currentThread().isInterrupted()){
                        // 干活
                    }
                }catch(InterruptedException e){
                    /* 允许线程退出 */
                }
            }
            public void cancel(){interrupt();}
        }

2. 线程run方法在实际执行前，会判断state。那么能改变state即可。但如果线程被阻塞，无法执行state判断逻辑，那也只能干看着了（每个线程都有一个boolean类型的中断状态，大部分阻塞库方法比如Object.wait、Thread.sleep是支持检查interrupt状态的）。

**所以要实现Future接口的方法，意味着我们要更大程度的介入线程的执行（或者说run方法中提供更多的埋点）。**


## FutureTask

我们来看一个Futrue的简单使用

    ExecutorService executor = Executors.newFixedThreadPool();
    Future<Integer> future = executor.submit(new MyJob()));
    
跟踪submit方法所属的类，Executors.newFixedThreadPool() ==> ThreadPoolExecutor ==> AbstractExecutorService

    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
    
   返回的future是一个FutureTask，FutureTask是`interface RunnableFuture<V> extends Runnable, Future<V>`的实现类。
 
以FutureTask为例，future如何取消一个任务。

executor执行FutureTask，最终运行的是FutureTask的run方法，那么在FutureTask的run方法中埋一些点（加一些检测），在cancel方法中改变下状态值就可以影响run方法的执行（如果此时这个run方法被某个线程执行）。

FutureTask的特别之处是它同时拥有run和cancel方法，所以执行cancel可以影响run方法的执行。那么，其它Future的实现类如何实现cancel呢？

## guava ListenableFuture和AbstractFuture

ListenableFuture的简单使用

    ListeningExecutorService executorService =             MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());
    final ListenableFuture<Integer> listenableFuture = executorService.submit(new MyJob<Integer>());
    // 添加监听事件
    Futures.addCallback(listenableFuture, new FutureCallback() {
        public void onSuccess(Integer result) {
          
        }
        public void onFailure(Throwable thrown) {
          
        }
    });


跟踪submit方法所属的类，ListeningExecutorService ==> AbstractListeningExecutorService ==> AbstractExecutorService

    public abstract class AbstractListeningExecutorService extends AbstractExecutorService{
        protected final <T> ListenableFutureTask<T> newTaskFor(Runnable runnable, T value){
            return ListenableFutureTask.create(runnable, value);
        }
        public <T> ListenableFuture<T> submit(Callable<T> task) {
            return (ListenableFuture)super.submit(task);
        }
    }
    public abstract class AbstractExecutorService implements ExecutorService{
        public <T> Future<T> submit(Callable<T> task) {
            if (task == null) throw new NullPointerException();
            RunnableFuture<T> ftask = newTaskFor(task);
            execute(ftask);
            return ftask;
        }
    }

实际执行的submit方法和上节的submit方法一样一样的，但在submit方法中，上节执行的是`AbstractExecutorService.newTaskFor`返回FutureTask，此处执行的是`AbstractListeningExecutorService.newTaskFor`返回ListenableFutureTask，其实际也是个`java.util.concurrent.FutureTask`。所以一个ListenableFuture具有cancel的能力就不奇怪了。**看来本质上，ListenableFutureTask取消任务的方式还是和FutureTask一样。**

ListenableFuture所具备的addListener方法则是任务挂在一个地方，当run方法执行完毕后，执行这些任务。（不同的guava版本实现代码有很大不同）

## 可以设置结果的Future

FutureTask中，get方法和run方法共享成员变量outcome，所以run方法跑完，设置下outcome，get方法就可以拿到返回outcome。（当然，涉及到状态判断与线程安全问题）

在可以设置结果的Future中，比如netty的Promise，outcome除run方法可以设置外，还提供了set方法设置outcome（当然，涉及到状态判断与线程安全问题）。

为什么要有set？一个可能的原因是，那些监听结果的listener有了一个统一的执行位置，比如NettyPromise的实现

    public Promise<V> setSuccess(V result){
        if(setSuccess0(result)){
            notifyListeners();
            return this;
        }
        throw new ILLegalStateExeception("complete already : " + this);
    }

否则，类似notifyListeners的操作，就需要自己监听状态了。

## 小结

在很多java库提供的Future实现中，其本质是FutureTask，即既包含执行逻辑，又包含对执行逻辑的控制（获取结果和取消等）。而有些框架的Future实现中，Future只包含线程安全的设置与获取结果的方法（或者说，只是对一个Object或变量的封装，使其安全访问），并不包含执行逻辑。